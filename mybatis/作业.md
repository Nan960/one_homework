#  作业

## 1.Mybatis动态sql是做什么的？都有哪些动态sql？简述一下动态sql的执行原理？



动态SQL作用:用来拼接SQL语句

动态SQL:

<if>||<foreach>||<trim>||<where>||<choose>||<set>

执行原理:

根据表达式动态拼接SQL



## 2.Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？

支持延迟加载;

仅支持association关联对象和collection对象的延迟加载;如果开启需要在mybatis配置文件中,手动开启延迟加载:lazyLoadingEnabled=true

原理:使用cglib创建目标对象的代理对象,当调用目标方法时候,进入拦截器方法,当发现A的属性对象B的属性值是null,就会调用查询B的关联SQL为B赋值,这样A就会得到B的属性对象值



## 3.Mybatis都有哪些Executor执行器？它们之间的区别是什么

BatchExecutor : 批量操作使用,执行update 操作,将所有的SQL(一个SQL一个statement对象)都添加到批处理中,等待统一执行

ReuseExecutor :  重用预处理语句preparedStatements  ,执行update或者select操作,以SQL作为key查找statement对象,存在就使用,不存在就创建,用完后,不关闭statement对象,而是放置在map内,等待下次使用

SimpleExecutor : 默认使用,每次使用update或者select操作,就会开始一个statement对象,用完之后关闭statement对象





## 4.简述下Mybatis的一级、二级缓存（分别从存储结构、范围、失效场景。三个方面来作答）

一级缓存

- 存储结构 : HashMap key==>id value==>实体类对象
- 范围 :同一个sqlSession
- 失效场景 :insert/delete/update操作会清除一级缓存

二级缓存

- 存储结构 : HashMap:key==>namespace+id  value==>序列化对象
- 范围 :多个sqlSession
- 失效场景 
  - 没有开启对应的配置,二级缓存默认是关闭的
  - 当没有执行sqlSession.close()操作时候,没有二级缓存写入到一级缓存中
  - insert/delete/update操作会清除二级缓存
  - 对象没有实现序列化接口



## 5.简述Mybatis的插件运行原理，以及如何编写一个插件

原理:

Mybatis仅可以编写针对ParameterHandler,ResultSetHandler,StatementHandler,Executor这4种接口的插件,每个创建出来的对象都不是直接返回的,而是interceptorChain.pluginAll(parameterHandler);调用interceptor.plugin(target)  返回target封装后的对象

编写:

```java
@Intercepts({
    @Signature(
        type = Executor.class, method = "query",
        args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}
    )
})
```





